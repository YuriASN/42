ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memccpy:    [MISSING]
ft_memmove:    [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your memmove does not support the overlap (test 1)
Test code:
	char dst1[0xF0];
	char dst2[0xF0];
	char *data = "thi√ü √ü\xde\xad\xbe\xeftri√±g will be √∏v√©rlap√©d !\r\n";
	int size = 0xF0 - 0xF;

	memset(dst1, 'A', sizeof(dst1));
	memset(dst2, 'A', sizeof(dst2));
	memcpy(dst1, data, strlen(data));
	memcpy(dst2, data, strlen(data));
	memmove(dst1 + 3, dst1, size);
	ft_memmove(dst2 + 3, dst2, size);
	if (!memcmp(dst1, dst2, size))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     memmove: |thithi√ü √üﬁ≠æÔtri√±g will be √∏v√©rlap√©d !
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAŒj|
  ft_memmove: |thithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithithiAAAAAAAAAAAAthithi√ü √üﬁ≠æÔtri√±g will be √∏v√©rlap√©d !
AAAAAAAAAAAAAA|

ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] [NO CRASH] 
[no crash]: your memcmp does not segfault when null parameter is sent
Test code:
	char b1[] = "nyancat";

	ft_memcmp(((void*)0), b1, 4);


[no crash]: your memcmp does not segfault when null parameter is sent
Test code:
	char b1[] = "nyancat";

	ft_memcmp(b1, ((void*)0), 4);


ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [FAILED] 
[fail]: your isalnum just doesn't work, REALLY ?!
Test code:
	int i;

	i = -1;
	while (i < 530)
	{
		if (!!ft_isalnum(i) != !!((*__ctype_b_loc ())[(int) ((i))] & (unsigned short int) _ISalnum))
			exit(TEST_FAILED);
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:


ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [FAILED] 
[fail]: your toupper just doesn't work, REALLY ?!
Test code:
	int i;

	i = -100;
	while (i < 530)
	{
		if (ft_toupper(i) != (__extension__ ({ int __res; if (sizeof (i) > 1) { if (__builtin_constant_p (i)) { int __c = (i); __res = __c < -128 || __c > 255 ? __c : (*__ctype_toupper_loc ())[__c]; } else __res = toupper (i); } else __res = (*__ctype_toupper_loc ())[(int) (i)]; __res; })))
		{
				;
			exit(TEST_FAILED);
		}
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:
     toupper: |156|
  ft_toupper: |-100|
param: (-100)

ft_tolower:    [FAILED] 
[fail]: your tolower just doesn't work, REALLY ?!
Test code:
	int i;

	i = -100;
	while (i < 530)
	{
		if (ft_tolower(i) != (__extension__ ({ int __res; if (sizeof (i) > 1) { if (__builtin_constant_p (i)) { int __c = (i); __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc ())[__c]; } else __res = tolower (i); } else __res = (*__ctype_tolower_loc ())[(int) (i)]; __res; })))
		{
				;
			exit(TEST_FAILED);
		}
		i++;
	}
	exit(TEST_SUCCESS);

Diffs:
     tolower: |156|
  ft_tolower: |-100|
param: (-100)

ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcat:    [OK] [FAILED] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + 4;
	size_t r1 = strlcat(buff1, str, max);
	size_t r2 = ft_strlcat(buff2, str, max);

	if (r1 != r2)
		exit(TEST_FAILED);
	char s1[4] = "";
	char s2[4] = "";
	r1 = strlcat(s1, "thx to ntoniolo for this test !", 4)
		;
	r2 = ft_strlcat(s2, "thx to ntoniolo for this test !", 4)
		;
	if (r1 != r2)
		exit(TEST_FAILED);
	exit(TEST_SUCCESS);

Diffs:
     strlcat: |42|
  ft_strlcat: |47|

[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + strlen("there is no stars in the sky");

	strlcat(buff1, str, max);
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the skythe cake is a lie |
  ft_strlcat: |there is no stars in the sky|

ft_strnstr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [OK] [OK] [OK] [OK] 
[KO]: your atoi does not work with over long max value
Test code:
	char n[40] = "99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |-1|
     ft_atoi: |-469762049|

[KO]: your atoi does not work with over long min value
Test code:
	char n[40] = "-99999999999999999999999999";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        atoi: |0|
     ft_atoi: |469762049|

ft_calloc:     [OK] [OK] [OK] [OK] [OK] 
ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] {protected}[OK] 
ft_strjoin:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_strtrim:    [FAILED] [FAILED] [OK] [FAILED] [OK] [KO] [FAILED] [OK] [FAILED] {not protected}
[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |	  

 		  


Hello 	  Please
 Trim me !
   
 
 		
|

[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |	  

 		  


Hello 	  Please
 Trim me !|

[fail]: your strtrim does not work with full blank input
Test code:
	char *s1 = "  \t \t \n   \n\n\n\t";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: ||
  ft_strtrim: |	 	 
   


	|

[KO]: your strtrim did not allocate the good size so the \0 test may be false
Test code:
	char *s1 = "\t   \n\n\n  \n\n\t    Hello \t  Please\n Trim me !\t\t\t\n  \t\t\t\t  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	int r_size = strlen(s2);
	int size;

	ft_strtrim(s1, " \n\t");
	size = get_last_malloc_size();
	if (size == r_size + 1)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
     strtrim: |27|
  ft_strtrim: |55|

[fail]: your strtrim does not allocate memory
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |	  

 		  


Hello 	  Please
 Trim me !
   
 
 		
|

[fail]: your strtrim does not set \0 to the end of the string
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";
	char *s2 = "Hello \t  Please\n Trim me !";

	char *ret = ft_strtrim(s1, " \n\t");
	if (!strcmp(s2, ret))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |	  

 		  


Hello 	  Please
 Trim me !
   
 
 		
|

ft_split:      [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [CRASH] [OK] [CRASH] {not protected}
[crash]: your split will segfault in case --> *str="\0aa\0bbb" c='\0' 
Test code:
	char **expected = ft_split("\0aa\0bbb", '\0');

	for (int i = 0; expected[i]; i++)
	{
		if (expected[i] != ((void*)0))
			exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);


[crash]: your split does not work with basic input
Test code:
	char *s = "split  ||this|for|me|||||!|";
	int i = 0;
	char **result = ft_split(s, '|');

	while (result[i])
	{
		if (strcmp(result[i], *expected))
		{
			exit(TEST_FAILED);
		}
		free(result[i]);
		i++;
		expected++;
	}
	free(result);
	exit(TEST_SUCCESS);


[crash]: your split does not work with basic input
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	while (*result)
	{
		if (strcmp(*result, *expected))
		{
			exit(TEST_FAILED);
		}
		result++;
		expected++;
	}
	exit(TEST_SUCCESS);


ft_itoa:       [FAILED] [FAILED] [OK] [CRASH] [FAILED] [OK] [OK] [OK] [CRASH] 
[fail]: your itoa does not work with basic input
Test code:
	char *i1 = ft_itoa(-623);
	char *i2 = ft_itoa(156);
	char *i3 = ft_itoa(-0);

	if (strcmp(i1, "-623"))
	{
		exit(TEST_FAILED);
	}
	if (strcmp(i2, "156"))
	{
		exit(TEST_FAILED);
	}
	if (strcmp("0", i3))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |156|
     ft_itoa: |156t protected}trim: |He!|

[fail]: your itoa does not work with random number
Test code:
	srand(clock());
	int n;
	char *d;

	for (int i = 0; i < 2000; i++)
	{
		n = rand();
		d = ft_itoa(n);
		if (atoi(d) != n)
		{
			exit(TEST_FAILED);
		}
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |1668341126|
     ft_itoa: |-669611914|

[crash]: your itoa does not work with min int
Test code:
	char *i1 = ft_itoa((-2147483647 -1));

	if (atoi(i1) != (-2147483647 -1))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);


[fail]: your itoa don't set \0 at the end of the string
Test code:

	char *i1 = ft_itoa(-1234);
	if (strcmp(i1, "-1234"))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-1234|
     ft_itoa: |-1234A|

[crash]: your itoa did not allocate memory for the int min value
Test code:
	char *i1 = ft_itoa((-2147483647 -1));

	fd_to_buffer(2);
	free(i1);
	write(2, "", 1);
	get_fd_buffer(2, ((void*)0), 0);
	exit(TEST_SUCCESS);


ft_strmapi:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_putchar_fd: [OK] [OK] 
ft_putstr_fd:  [OK] [OK] {not protected}
ft_putendl_fd: [OK] [OK] {not protected}
ft_putnbr_fd:  [OK] [OK] [CRASH] [OK] [CRASH] 
[crash]: your putnbr_fd does not work with int min
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your putnbr_fd allocate memory, wtf ???
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_lstnew:     [OK] [OK] [OK] [OK] 
ft_lstadd_front: [OK] [OK] [OK] 
ft_lstsize:    [OK] [OK] 
ft_lstlast:    [OK] [OK] 
ft_lstadd_back:[OK] [OK] [OK] 
ft_lstdelone:  [OK] 
ft_lstclear:   [CRASH] [OK] [CRASH] 
[crash]: your lstclear does not work with basic input
Test code:
	t_list *l = lstnew(strdup("nyancat"));

	l->next = lstnew(strdup("#TEST#"));
	ft_lstclear(&l, lstdelone_f);
	write(2, "", 1);
	if (!l)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: bad call number of the function pointer
Test code:
	char *content = "hello !";

	__delNum = 0;
	list = malloc(sizeof(t_list));
	bzero(list, sizeof(t_list));
	list->next = malloc(sizeof(t_list));
	bzero(list->next, sizeof(t_list));
	list->content = content;
	list->next->content = content + 2;
	ft_lstclear(&list, lstdel_f);
	write(2, "", 1);
	if (__delNum == 2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_lstiter:    [OK] {protected}
ft_lstmap:     [CRASH] {protected}
[crash]: your lstmap does not work with basic input
Test code:
	t_list *l = lstnew(strdup(" 1 2 3 "));
	t_list *ret;

	l->next = lstnew(strdup("ss"));
	l->next->next = lstnew(strdup("-_-"));
	ret = ft_lstmap(l, lstmap_f, ((void*)0));
	if (!strcmp(ret->content, "OK !") && !strcmp(ret->next->content, "OK !") && !strcmp(ret->next->next->content, "OK !") && !strcmp(l->content, " 1 2 3 ") && !strcmp(l->next->content, "ss") && !strcmp(l->next->next->content, "-_-"))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_striteri:   [OK] [OK] {not protected}
