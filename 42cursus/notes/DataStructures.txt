TYPEDEF

typedef int* pointerparaint; 	//pointerparaint = int*
								typedef e' parecido com o DEFINE mas pode ser utilizado dentro de funcoes.
								typdefS de pointer fara de todas as variaveis separadas por "," um pointer,
								no caso do DEFINE ela fara' apenas a primeira variavel um pointer e o restante int.
								ex.: typedef char* charp; | cahrp a, b, c; (a b e c sao pointers).
									 #define charp char* | cahrp a, b, c; (a e' pointer mas b e c nao).


STRUCTs

typedef + struct. // na hora de decalrar o nome do tipo da estrutura se torna resumido. ex.:
	typedef struct	s_point
	{
		int x;
		int y;
	}				t_point;

	int	main(void)
	{
		t_point a;
		t_point b;
		...
	}
	//Declarei a e b como estruturas s_point. reduzi o usual "struct s_point a;" para t_point a;
	Para dar valor à uma variável usa-se "a.x = 10"

pointer de struct
	Para indicar a varialvel dentro com um pointer de uma struct utiliza-se "->", ex.:
		pointer->x = 10; //A variavel X da estrutura para qual o pointer aponta e' igual a 10


ENUM

os valores das variaveis de enum sao sempre +1 que a variavel anterior.
Se valores nao forem definidos a primeira variavel tem o valor de 0;
ex.:
enum	e_list
{
	value1 = 7;
	value2;
	value3;
	value4;
};

int	main(void)
{
	enum e_list a; //Cria a variavel a, que trabalha pelo valor da lista.

	a = value3;	//Da o valor de value 3 (9) a variavel a.
}


UNION
https://www.youtube.com/watch?v=iiyjeAPeHN8
A UNION e' basicamente uma STRUCT. A diferenca esta' na alocacao de memoria.
Uma struct aloca memoria para todos elementos nela,
enquando a UNION aloca apenas memoria suficiente para cobrir o maior elemento. ex.:
{
	int a;		//4 bytes
	char c;		//1 byte
	float b;	//4 bytes
};

Caso o exemplo acima seja declarado como STRUCT ele alocara' 9 bytes na memoria para cobrir todos itens.
No caso da UNION ela alocara' apenas 4, que e' o maior valor presente.

A UNION e' boa para usar pouca memoria, mas dece ser utilizada apenas quando for definir apenas uma das variaveis.
Se voce der um valor a 'a' e depois um valor a 'b', o valor de b ira' sobrepor o valor de 'a'.

Com a union tambem pode-se fazer operacoes byte a byte. ex.:
union	tipo
{
	short int		x;						//8 bytes
	unsigned char	c[4];		//1 byte
};

..main..
{
	union tipo a;
	a.x = 1545;						//00000110 00001001
	printf("x = %d\n", a.x);
	printf("c[0] = %d\n", a.c[0]);	//00000110
	printf("c[1] = %d\n", a.c[1]);	//00001001
		//note que ao dar printf dos chars o indicador utilizado foi o "%d" pois procuramos no valor do char uma int.
}